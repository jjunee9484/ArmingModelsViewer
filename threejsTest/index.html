<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Blender Toon Viewer - Outline & Gradient</title>
    <style>
        body { margin: 0; overflow: hidden; background: #444488; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; display: flex; flex-direction: column; gap: 10px; }
        .btn-group { display: flex; gap: 5px; }
        button, label { 
            padding: 10px 15px; cursor: pointer; background: rgba(40, 40, 40, 0.9); color: white; 
            border: 1px solid #444; border-radius: 6px; font-weight: bold; font-size: 12px; transition: 0.3s;
        }
        button:hover, label:hover { background: #555; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        .active { background: #4a90e2 !important; border-color: #6fb1fc !important; }
        #fileInput { display: none; }
        .upload-btn { background: #27ae60 !important; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="btn-group">
            <input type="file" id="fileInput" accept=".glb,.gltf">
            <label for="fileInput" class="upload-btn">üìÇ OPEN GLB (TOON)</label>
        </div>
        <div class="btn-group">
            <button id="blenderCamBtn" disabled>FIXED CAM</button>
            <button id="freeCamBtn" class="active">FREE CAM</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';

        let scene, renderer, effect, controls, mixer, clock, currentModel;
        let defaultCamera, blenderCamera, activeCamera;
        let gradientMap;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x444488);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 1. OutlineEffect ÏÑ§Ï†ï (Í≤ÄÏùÄÏÉâ Ïô∏Í≥ΩÏÑ†)
            effect = new OutlineEffect(renderer);

              // 1. 256Îã®Í≥ÑÏùò Î∂ÄÎìúÎü¨Ïö¥ Í∑∏ÎùºÎç∞Ïù¥ÏÖò Î∞∞Ïó¥ ÏÉùÏÑ±
            const colors = new Uint8Array(256);
            for (let i = 0; i < 256; i++) {
                colors[i] = i; // 0Î∂ÄÌÑ∞ 255ÍπåÏßÄ Ï∞®Î°ÄÎåÄÎ°ú Ï±ÑÏõÄ
            }
            
            // 2. Îç∞Ïù¥ÌÑ∞ ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
            gradientMap = new THREE.DataTexture(colors, colors.length, 1, THREE.RedFormat);
            
            // 3. ÌïµÏã¨: ÌïÑÌÑ∞ÎßÅÏùÑ Linear(ÏÑ†Ìòï)Î°ú ÏÑ§Ï†ïÌïòÏó¨ ÌîΩÏÖÄ ÏÇ¨Ïù¥Î•º Î∂ÄÎìúÎüΩÍ≤å Î≠âÍ∞úÏ§å
            gradientMap.magFilter = THREE.LinearFilter;
            gradientMap.minFilter = THREE.LinearFilter;
            gradientMap.generateMipmaps = false; // ÏÑ±Îä•ÏùÑ ÏúÑÌï¥ ÎØ∏ÏûÖÎßµÏùÄ ÎÅî
            gradientMap.needsUpdate = true;

            // Ïπ¥Î©îÎùº ÏÑ§Ï†ï
            defaultCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            defaultCamera.position.set(5, 5, 5);
            activeCamera = defaultCamera;

            // Ï°∞Î™Ö (Ìà∞ ÏâêÏù¥ÎçîÎäî Ï°∞Î™Ö ÏúÑÏπòÏóê Îî∞Îùº Î™ÖÏïîÏù¥ Í≤∞Ï†ïÎê®)
            const ambient = new THREE.AmbientLight(0xffffff, 3.5);
            scene.add(ambient);

            const directLight = new THREE.DirectionalLight(0xffffff, 2);
            directLight.position.set(5, 10, 7.5);
            scene.add(directLight);

            controls = new OrbitControls(defaultCamera, renderer.domElement);
            controls.enableDamping = true;

            clock = new THREE.Clock();

            // UI Ïù¥Î≤§Ìä∏
            document.getElementById('freeCamBtn').onclick = () => switchCamera('free');
            document.getElementById('blenderCamBtn').onclick = () => switchCamera('blender');
            document.getElementById('fileInput').onchange = (e) => loadLocalFile(e);

            window.addEventListener('resize', onWindowResize);
        }

        function loadModel(data) {
            const loader = new GLTFLoader();
            if (currentModel) scene.remove(currentModel);
            if (mixer) mixer.stopAllAction();

            loader.parse(data, '', (gltf) => {
                currentModel = gltf.scene;

                // 3. Î™®Îç∏Ïùò Î™®Îì† Ïû¨ÏßàÏùÑ ToonMaterialÎ°ú Í∞ïÏ†ú ÍµêÏ≤¥
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshToonMaterial({
                            color: oldMat.color,
                            map: oldMat.map, // Í∏∞Ï°¥ ÌÖçÏä§Ï≤ò Ïú†ÏßÄ
                            gradientMap: gradientMap // Ìà∞ Îã®Í≥Ñ Ï†ÅÏö©
                        });
                    }
                });

                scene.add(currentModel);

                // Ïï†ÎãàÎ©îÏù¥ÏÖò
                mixer = new THREE.AnimationMixer(currentModel);
                gltf.animations.forEach(clip => mixer.clipAction(clip).play());

                // Ïπ¥Î©îÎùº Ï≤¥ÌÅ¨
                if (gltf.cameras.length > 0) {
                    blenderCamera = gltf.cameras[0];
                    blenderCamera.aspect = window.innerWidth / window.innerHeight;
                    blenderCamera.updateProjectionMatrix();
                    document.getElementById('blenderCamBtn').disabled = false;
                    switchCamera('blender');
                } else {
                    blenderCamera = null;
                    document.getElementById('blenderCamBtn').disabled = true;
                    switchCamera('free');
                }
            });
        }

        function switchCamera(type) {
            const fBtn = document.getElementById('freeCamBtn');
            const bBtn = document.getElementById('blenderCamBtn');

            if (type === 'free') {
                activeCamera = defaultCamera;
                controls.enabled = true;
                fBtn.classList.add('active');
                bBtn.classList.remove('active');
            } else if (type === 'blender' && blenderCamera) {
                activeCamera = blenderCamera;
                controls.enabled = false;
                bBtn.classList.add('active');
                fBtn.classList.remove('active');
            }
        }

        function onWindowResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            defaultCamera.aspect = w / h;
            defaultCamera.updateProjectionMatrix();
            if (blenderCamera) {
                blenderCamera.aspect = w / h;
                blenderCamera.updateProjectionMatrix();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            if (controls.enabled) controls.update();

            // 4. ÏùºÎ∞ò renderer ÎåÄÏã† effect(Outline)Î°ú Î†åÎçîÎßÅ
            effect.render(scene, activeCamera);
        }

        function loadLocalFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => loadModel(e.target.result);
            reader.readAsArrayBuffer(file);
        }
    </script>
</body>
</html>