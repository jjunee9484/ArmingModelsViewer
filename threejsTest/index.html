<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Blender Web Viewer - Camera Switch</title>
    <style>
        body { margin: 0; overflow: hidden; background: #ffffff; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; display: flex; gap: 10px; }
        button { 
            padding: 10px 20px; cursor: pointer; background: #333; color: white; 
            border: none; border-radius: 5px; font-weight: bold; 
        }
        button:hover { background: #555; }
        .active { background: #4a90e2; }
    </style>
</head>
<body>

    <div id="ui">
        <button id="blenderCamBtn">고정 카메라</button>
        <button id="freeCamBtn" class="active">자유 카메라</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    // ... (위쪽 HTML/CSS는 동일)

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, renderer, controls, mixer, clock;
        let defaultCamera, blenderCamera, activeCamera;

        // 자유 카메라 초기 위치 설정값
        const INITIAL_FREE_CAM_POS = { x: 5, y: 5, z: 5 };

        init();
        loadAnimFile();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // 배경을 약간 어둡게 해서 조명 효과 강조

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 렌더러 품질 설정 (그림자 및 물리 기반 렌더링 최적화)
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // 1. 기본 카메라
            defaultCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            resetFreeCamera(); // 초기 위치 설정
            activeCamera = defaultCamera;

            // 2. 컨트롤
            controls = new OrbitControls(defaultCamera, renderer.domElement);
            controls.enableDamping = true;

            // 3. 조명 리뉴얼 (너무 밝은 AmbientLight 대신 입체적 조명 배치)
            setupLights();

            clock = new THREE.Clock();

            document.getElementById('freeCamBtn').onclick = () => switchCamera('free');
            document.getElementById('blenderCamBtn').onclick = () => switchCamera('blender');

            window.addEventListener('resize', onWindowResize);
        }

        function setupLights() {
            // 은은한 전체 조명 (강도를 낮춤)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // 메인 조명 (태양광 역할 - 대각선 위)
            const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
            mainLight.position.set(5, 10, 7.5);
            scene.add(mainLight);

            // 반사광 (모델의 그림자 부분을 살짝 채워줌)
            const fillLight = new THREE.PointLight(0x4a90e2, 1.5); // 약간 푸른빛
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);
        }

        function resetFreeCamera() {
            defaultCamera.position.set(INITIAL_FREE_CAM_POS.x, INITIAL_FREE_CAM_POS.y, INITIAL_FREE_CAM_POS.z);
            if (controls) {
                controls.target.set(0, 0, 0); // 원점을 바라보게 초기화
                controls.update();
            }
        }

        function loadAnimFile() {
            const loader = new GLTFLoader();
            loader.load('./anim.glb', (gltf) => {
                const model = gltf.scene;
                scene.add(model);

                mixer = new THREE.AnimationMixer(model);
                gltf.animations.forEach(clip => mixer.clipAction(clip).play());

                if (gltf.cameras.length > 0) {
                    blenderCamera = gltf.cameras[0];
                    blenderCamera.aspect = window.innerWidth / window.innerHeight;
                    blenderCamera.updateProjectionMatrix();
                } else {
                    const btn = document.getElementById('blenderCamBtn');
                    btn.innerText = "카메라 데이터 없음";
                    btn.disabled = true;
                }
            }, undefined, (err) => {
                console.error("파일 로드 실패");
            });
        }

        function switchCamera(type) {
            const freeBtn = document.getElementById('freeCamBtn');
            const blenderBtn = document.getElementById('blenderCamBtn');

            if (type === 'free') {
                activeCamera = defaultCamera;
                resetFreeCamera(); // 전환 시 위치 초기화 호출
                controls.enabled = true;
                freeBtn.classList.add('active');
                blenderBtn.classList.remove('active');
            } else if (type === 'blender' && blenderCamera) {
                activeCamera = blenderCamera;
                controls.enabled = false;
                blenderBtn.classList.add('active');
                freeBtn.classList.remove('active');
            }
        }

        // ... (onWindowResize 및 animate 함수는 동일)
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            defaultCamera.aspect = aspect;
            defaultCamera.updateProjectionMatrix();
            if (blenderCamera) {
                blenderCamera.aspect = aspect;
                blenderCamera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            if (controls.enabled) controls.update();
            renderer.render(scene, activeCamera);
        }
    </script>
</body>
</html>